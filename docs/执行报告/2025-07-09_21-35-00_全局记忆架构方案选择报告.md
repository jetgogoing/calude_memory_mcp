# 📋 全局记忆架构方案选择报告

**任务概述**：比较两个架构方案，选择最适合保持stdio模式同时实现跨项目记忆共享的方案
**执行时间**：2025-07-09 21:35:00
**分析模型**：Gemini 2.5 Pro (深度思考模式)

---

## 🎯 需求分析

用户的核心需求：
1. **保持 stdio 模式**（硬性要求）
2. 实时存储聊天记录
3. 跨项目查询记忆
4. 保持 MCP 全局注册

---

## 📊 方案对比

### 方案一：global-service-architecture

**核心理念**：完全迁移到 API 模式

**架构特点**：
- 推荐放弃 stdio，改用 HTTP API
- 单一 API 服务器处理所有请求
- 真正的多客户端并发支持

**评估**：
- ❌ 不符合"保持 stdio"的要求
- ✅ 技术上更先进
- ❌ 需要大幅修改现有架构

### 方案二：global_memory_center_deploy

**核心理念**：混合架构（stdio + API + Collector）

**架构特点**：
- MCP 保持 stdio 模式
- 添加后台 API 服务器作为数据中心
- ConversationCollector 自动收集对话
- 统一使用 `project_id="global"`

**评估**：
- ✅ 完美满足"保持 stdio"的要求
- ✅ 实现了所有功能需求
- ✅ 最小侵入性，渐进式改进

---

## 🏆 推荐方案：global_memory_center_deploy

### 架构设计

```
用户交互层
├── Claude CLI（任何项目）
│   └── stdio 通信
│
服务层
├── MCP Server（stdio模式）
│   ├── 响应工具调用
│   └── 转发到 API Server
│
├── API Server（HTTP服务）
│   ├── 数据存储接口
│   ├── 查询接口
│   └── 健康检查
│
└── ConversationCollector
    ├── 监听 CLI 日志
    └── 自动存储对话
    
数据层
├── PostgreSQL（结构化数据）
└── Qdrant（向量搜索）
```

### 工作流程

1. **工具调用流程**：
   ```
   Claude CLI --stdio--> MCP Server --HTTP--> API Server ---> Database
   ```

2. **自动收集流程**：
   ```
   Claude CLI --写日志--> ~/.claude/conversations/*.jsonl
                              |
                              v
                        ConversationCollector --HTTP--> API Server
   ```

3. **跨项目查询**：
   - 所有数据使用 `project_id="global"`
   - 任何项目都能查询到所有记忆

---

## 💡 关键创新点

1. **保持兼容性**：stdio 接口完全不变
2. **解耦设计**：各组件独立运行，易于维护
3. **自动化**：对话自动收集，无需手动保存
4. **统一存储**：打破项目隔离，实现真正共享

---

## 🚀 实施路线图

### Phase 1：基础设施（1-2天）
- [x] 数据库和向量库已部署
- [ ] 启动 API Server 作为独立服务
- [ ] 配置统一的 `project_id="global"`

### Phase 2：自动收集（2-3天）
- [ ] 激活 ConversationCollector
- [ ] 配置日志监听路径
- [ ] 测试自动存储功能

### Phase 3：MCP 集成（1-2天）
- [ ] 修改 MCP 工具调用逻辑
- [ ] 添加 HTTP 客户端代码
- [ ] 保持 stdio 接口不变

### Phase 4：验证优化（持续）
- [ ] 跨项目测试
- [ ] 性能优化
- [ ] 添加监控

---

## 🔧 技术细节

### 关键代码修改

1. **统一 project_id**：
   ```python
   # 所有地方统一使用
   PROJECT_ID = os.getenv("CLAUDE_MEMORY_PROJECT_ID", "global")
   ```

2. **MCP 工具转发**：
   ```python
   # 在 MCP 工具方法中
   async def memory_search(query):
       # 原本直接查数据库
       # 改为调用 API
       response = await http_client.post(
           f"{API_URL}/search",
           json={"query": query, "project_id": "global"}
       )
       return response.json()
   ```

3. **Collector 配置**：
   ```python
   # 监听路径
   WATCH_PATHS = [
       Path.home() / ".claude/conversations",
       Path.home() / ".local/share/claude/logs"
   ]
   ```

---

## ⚠️ 风险与缓解

### 风险1：服务管理复杂度
**缓解**：提供一键启动脚本和 systemd 服务

### 风险2：数据一致性
**缓解**：使用事务和适当的并发控制

### 风险3：性能瓶颈
**缓解**：API Server 支持水平扩展

---

## 📈 预期效果

1. **即时生效**：对话实时保存，无需手动操作
2. **全局可见**：任何项目都能访问所有记忆
3. **向后兼容**：现有 stdio 接口完全不变
4. **易于扩展**：未来可添加更多功能

---

## 🎯 结论

**global_memory_center_deploy** 方案通过巧妙的混合架构设计，在满足所有技术约束的同时，实现了用户的全部需求。这是一个务实、优雅且可扩展的解决方案。

---

**决策**：✅ 采用 global_memory_center_deploy 方案
**信心等级**：非常高（基于深度技术分析）
**下一步**：按照实施路线图开始部署