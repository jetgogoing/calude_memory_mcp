[
  {
    "timestamp": "2024-01-06T10:30:45.123456",
    "type": "user",
    "content": "Hello Claude, can you help me write a Python function to calculate fibonacci numbers?",
    "session_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "metadata": {
      "source": "claude_cli",
      "version": "1.0"
    }
  },
  {
    "timestamp": "2024-01-06T10:30:50.789012",
    "type": "assistant", 
    "content": "I'd be happy to help you write a Python function to calculate Fibonacci numbers. Here are a few different approaches:\n\n```python\ndef fibonacci_recursive(n):\n    \"\"\"Recursive approach - simple but inefficient for large n\"\"\"\n    if n <= 1:\n        return n\n    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)\n\ndef fibonacci_iterative(n):\n    \"\"\"Iterative approach - more efficient\"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```\n\nThe iterative version is much more efficient for larger numbers.",
    "session_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "metadata": {
      "source": "claude_cli",
      "version": "1.0"
    }
  },
  {
    "timestamp": "2024-01-06T10:31:15.456789",
    "type": "user",
    "content": "That's great! Can you also show me how to add memoization to the recursive version?",
    "session_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "metadata": {
      "source": "claude_cli",
      "version": "1.0"
    }
  },
  {
    "timestamp": "2024-01-06T10:31:20.987654",
    "type": "assistant",
    "content": "Absolutely! Memoization can dramatically improve the performance of the recursive approach. Here's how you can implement it:\n\n```python\ndef fibonacci_memoized(n, memo={}):\n    \"\"\"Recursive with memoization - efficient and elegant\"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n <= 1:\n        return n\n    \n    memo[n] = fibonacci_memoized(n-1, memo) + fibonacci_memoized(n-2, memo)\n    return memo[n]\n\n# Alternative using functools.lru_cache decorator\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fibonacci_cached(n):\n    \"\"\"Using built-in LRU cache decorator\"\"\"\n    if n <= 1:\n        return n\n    return fibonacci_cached(n-1) + fibonacci_cached(n-2)\n```\n\nBoth versions eliminate redundant calculations by storing previously computed values.",
    "session_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "metadata": {
      "source": "claude_cli",
      "version": "1.0"
    }
  }
]